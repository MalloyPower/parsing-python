@contributor{James Power - jpower@cs.nuim.ie - Maynooth, Ireland}
module extract::SimpleEBNF2BGF
/*
 * Parser for the EBNF that gets generated by ppx routines.
 * options use x?, otherwise the same as PyEBNF
 * Not really used very much.
 */


import String; 
import IO;

import MyGrammar;
import extract::PyTokens;

import grammarlab::io::Grammar;
import grammarlab::lib::Sizes;

import grammarlab::export::Grammar; // ppx


syntax SEBNFGrammar =  SEBNFLayoutList SEBNFProduction+ SEBNFLayoutList;
syntax SEBNFProduction = SEBNFNonterminal SEBNFDefAs {SEBNFDefinition "|"}+ ";" ;
syntax SEBNFDefinition = SEBNFSequence;
syntax SEBNFSequence = SEBNFSymbol+;
syntax SEBNFSymbol
 = nonterminal: SEBNFNonterminal
 | terminal: SEBNFTerminal
 | group: "(" {SEBNFDefinition "|"}+ ")"
 | option: SEBNFSymbol "?"
 | star: SEBNFSymbol "*"
 | plus: SEBNFSymbol "+";
lexical SEBNFTerminal 
  = @category="Constant" "\'" SEBNFSingleQuotedSymbols name "\'" 
  | @category="Constant" "\"" SEBNFDoubleQuotedSymbols name "\"" 
  ;
lexical SEBNFSingleQuotedSymbols = ![\']* !>> ![\'];
lexical SEBNFDoubleQuotedSymbols = ![\"]* !>> ![\"];
lexical SEBNFNonterminal = @category="Identifier"  SEBNFNonterminalSymbols name ;
lexical SEBNFDefAs = ":" | "::=" ;
lexical SEBNFNonterminalSymbols = [A-Za-z_01-9]+ !>> [A-Za-z_01-9];
layout SEBNFLayoutList = SEBNFLayout* ;
lexical SEBNFLayout = [\t-\n\r\ ]* !>> [\t-\n\r\ ] | SEBNFComment ;
lexical SEBNFComment = @category="Comment" "#" ![\n]* >>[\n];

//Tree getSEBNF(str s,loc z) = parse(#SEBNFGrammar,z);
//public void registerSEBNF() = registerLanguage("SEBNF","SEBNF",getSEBNF);

private GGrammar mapG((SEBNFGrammar)`<SEBNFProduction+ ps>`)
{
	GProdList ps2 = []; 
	list[str] nts = [];
	for(p <- ps) {
		p2 = mapP(p); 
		if(p2.lhs notin nts)
			nts += p2.lhs; 
		ps2 += p2;
	}
	return grammar(nts, ps2, []);
}
private GProdList mapPs(SEBNFProduction+ ps) = [mapP(p) | p <- ps];
private GProd mapP((SEBNFProduction)`<SEBNFNonterminal lhs> <SEBNFDefAs _> <{SEBNFDefinition "|"}+ rhds> ;`) 
  = production("<lhs>",mapDs(rhds));


private GExpr mapDs({SEBNFDefinition "|"}+ ds)
{
	GExprList es = [mapD(d) | SEBNFDefinition d <- ds];
	return (len(es)==1) ? es[0] : choice(es);
}
private GExpr mapS((SEBNFSymbol)`<SEBNFNonterminal n>`) = nonterminal("<n.name>");
private GExpr mapS((SEBNFSymbol)`<SEBNFTerminal t>`) = terminal("<t.name>");
private GExpr mapS((SEBNFSymbol)`(<{SEBNFDefinition "|"}+ ds>)`) = mapIDs(ds);
private GExpr mapS((SEBNFSymbol)`<SEBNFSymbol smb>?`) = optional(mapS(smb));
private GExpr mapS((SEBNFSymbol)`<SEBNFSymbol smb>*`) = star(mapS(smb));
private GExpr mapS((SEBNFSymbol)`<SEBNFSymbol smb>+`) = plus(mapS(smb));
private default GExpr mapS(SEBNFSymbol smb) {println("Cannot map symbol <smb>!");return empty();}

private GExpr mapIDs({SEBNFDefinition "|"}+ ds)
{
	GExprList es = [mapD(d) | SEBNFDefinition d <- ds];
	return (len(es)==1) ? es[0] : choice(es);
}
private GExpr mapD((SEBNFDefinition)`<SEBNFSequence d>`) = mapE(d);
private GExpr mapE((SEBNFSequence)`<SEBNFSymbol s>`) = mapS(s);
private default GExpr mapE((SEBNFSequence)`<SEBNFSymbol+ ss>`) = sequence([mapS(s) | SEBNFSymbol s <- ss]);


public Tree parseSEBNF(loc z) = parse(#SEBNFGrammar, trim(readFile(z))+"\n");

public GGrammar extractG(loc ebnfLoc) = mapG(parseSEBNF(ebnfLoc));
public GGrammar extractG(str ebnfFile) =  extractG(|cwd:///| + ebnfFile);



public void main(list[str] args)
{
	GGrammar gram = extractG(args[0]);
	if (len(args) > 1) {
		loc outLoc = |cwd:///|+args[1];
		writeBGF(gram, outLoc);
		println("output written to <outLoc>");
	} else {
		println("Result is: <ppx(gram)>");
	}
} 


public void main(str arg) { main([arg]); }
