@contributor{James Power - jpower@cs.nuim.ie - Maynooth, Ireland}
module pygrat::RunTransformation

// These are the driver routines to bison-ify a grammar (the actual work is done in Gram2Bison).
// These drivers bisonify using the Bisonify.rsc code, 
// and then run the XBGF transformations, and compare the result.

// A lot of this code is adapted from GrammarLab's 'test' folder...

import Prelude;
import util::Maybe;

import grammarlab::language::glue::Interpreter;   // execute
import grammarlab::io::GLUE;   // loadGlue

import grammarlab::language::glue::abstract::Top;  // For GLUE (abstract syntax)
import grammarlab::transform::XBGF; // for vtransform
import grammarlab::language::X; // for XCommand
import grammarlab::language::XOutcome; // for XResult
import grammarlab::transform::Normal; // for normalise

import pygrat::MyGrammar;
import pygrat::misc::SiteSpecific;
import pygrat::misc::Util;

import pygrat::extract::Extracters;
import pygrat::extract::PyEBNF2BGF;  // preparePythonGrammar

import pygrat::extract::Gram2Bison;
import pygrat::extract::Gram2Menhir;
import pygrat::CompareGrammars;

 
// A version of execute that is tolerant of a certain number of errors:
// This is just hacked from grammarlab::language::glue::Interpreter
private tuple[GGrammar, int] maybeExecute(GGrammar g, GLUE cmdList, int tolerance)
{
	int seenErrors = 0;
	for (xbgf(XCommand cmd) <- cmdList) {
		XOutcome res = ok();
		try  <res, g> = vtransform(cmd, g);
		catch errmsg : res = problem(errmsg);
		if (ok() := res)
			g = normalise(g);
		else {
			seenErrors += 1;
			println("[ERROR #<seenErrors>] Command not executed due to XBGF error:");
			report(res);
			if (seenErrors > tolerance) {
				println("[ERROR] Too many errors - aborting this sequence now.");
				return <g, seenErrors>;
			}
		}
	}
	return <g, seenErrors>;
}



// Run one list of transformations over a grammar, return the resulting grammar.
private tuple[GGrammar, int] runOneTransform(GGrammar gInput, loc gluefile, int tolerance) 
{
    println("------ Reading commands from <gluefile>");
    GLUE cmds = loadGlue(gluefile);
    return maybeExecute(gInput, cmds, tolerance); 
}

// Read a Python grammar from a file and transform it.
// In case of exception the last valid grammar is returned.
GGrammar runTransforms(loc gramfile, list[loc] gluList, int tolerance)
{ 
	println("Reading grammar from <gramfile>");
	GGrammar pyg = extractGrammar(gramfile);
	map[loc, int] errorRecord = ();
	for (loc gluefile <- gluList) {
		<pyg, errorCount> = runOneTransform(pyg, gluefile, tolerance);
    	if (errorCount>0) 
    		errorRecord[gluefile] = errorCount;
	}
	if (! isEmpty(errorRecord)) {
		println("The following XBGF files contained errors:");
		for (loc gf <- errorRecord)
			println("\t<gf>: <errorRecord[gf]> errors");
	}
	return pyg;
}

// Read a Python grammar from a file, transform it, and write results to the given file.
// Return the transformed grammar.
GGrammar runTransforms(loc gramfile, list[loc] gluList, loc outfile, int tolerance)
{ 
	GGrammar pyg = runTransforms(gramfile, gluList, tolerance);
	writeFile(outfile, "// Generated by transforming <gramfile> on <today()>\n");
	if (endsWith(outfile.file, dot(BISON_GRAMMAR_SUFFIX)))
		appendToFile(outfile, ["<s>\n" | s <- strBison(pyg)]);
	else if (endsWith(outfile.file, dot(MENHIR_GRAMMAR_SUFFIX)))
		appendToFile(outfile, ["<s>\n" | s <- strMenhir(pyg)]);
	return pyg;
}
GGrammar runTransforms(loc gramfile, loc glufile, loc outfile) 
  = runTransforms(gramfile, [glufile], outfile, 0);


// Running the .glue file over the original grammar should give you the same as the .y file.
void checkBisonifyGlue(loc originalGrammar, loc generatedGrammar, list[loc] glufileList)
{
	// First run the glue file(s)
	GGrammar glueGram = runTransforms(originalGrammar, glufileList, 0);
	// Grammars from Gram2Bison::translateFile will have been tidied and augmented, so for comparison:
	glueGram = preparePythonGrammar(glueGram);
	// Now check the output against the generated .y file:
	GGrammar rascGram = extractGrammar(generatedGrammar);
	if (gdts(rascGram, glueGram))
		println("Success: grammars are identical.");
	else
		println(gdtv_str(rascGram, glueGram));
}

// Read the Python grammar in infolder+infile and bisonify it.
// Generate two files in outfolder: the code-generated bison .y file and a corresponding .glue file.
public void generateBisonTransform(loc infolder, str infile,  loc outfolder)
{
	assert isDirectory(infolder) : "<infolder> is not a directory";
	assert isDirectory(outfolder) : "<outfolder> is not a directory";
	assert isFile(infolder+infile) : "<infile> is not a file in <infolder>";
	str ext = (infolder+infile).extension;
	assert ext notin [BISON_GRAMMAR_SUFFIX, GLUE_FILE_SUFFIX] : "I will need to overwrite these";
	str filestem = delExt(infolder, infile);
	str outfile = filestem + dot(BISON_GRAMMAR_SUFFIX);
	str glufile = filestem + "-bisonify" + dot(GLUE_FILE_SUFFIX);
	// First of all, make the glue file:
	println("Translating <infile>");
	pygrat::Gram2Bison::translateFile(infolder+infile, outfolder+outfile, outfolder+glufile);
	checkBisonifyGlue(infolder+infile, outfolder+outfile, [outfolder+glufile]);
}

public void generateBisonTransform(loc infolder, str infile) = generateBisonTransform(infolder, infile, infolder);

///////////////////////////////////////
///// Site-specific test routines /////
///////////////////////////////////////


void p() {
    runTransforms(wip("old-print-stmt.y"), 
                  [wip("print-manual.glue")], 
                  wip("new-print-stmt.y"), 
                  0);
}

