// Automatically generated from 0.9.1.txt on 2016-11-23 at 16:45:38 +0000
// Transformations to convert (bisonify) 0.9.1.txt to 0.9.1.y

// replace embedded choice in file_input ::= "NEWLINE" | stmt
extract pick_NEWLINE_stmt ::= "NEWLINE" | stmt; in file_input.
// replace star in file_input ::= pick_NEWLINE_stmt*
extract star_1 ::= pick_NEWLINE_stmt*; in file_input.
yaccify star_1 ::= (star_1 pick_NEWLINE_stmt) | ε;. // replaces pick_NEWLINE_stmt*
// expand top-level with a single option in parameters ::= "LPAR" fplist? "RPAR"
massage fplist? to (fplist | ε) in parameters.
distribute in parameters.
// expand top-level tail iteration in fplist ::= fpdef ("COMMA" fpdef)*
yaccify fplist ::= (fpdef) | (fplist ("COMMA" fpdef));. // replaces fpdef ("COMMA" fpdef)*
// replace star in expr_stmt ::= (exprlist "EQUAL")*
extract star_exprlist_EQUAL ::= (exprlist "EQUAL")*; in expr_stmt.
yaccify star_exprlist_EQUAL ::= (star_exprlist_EQUAL (exprlist "EQUAL")) | ε;. // replaces (exprlist "EQUAL")*
// expand top-level with a single option in print_stmt ::= "PRINT" (test "COMMA")* test? "NEWLINE"
massage test? to (test | ε) in print_stmt.
distribute in print_stmt.
// replace star in print_stmt ::= (test "COMMA")*
extract star_test_COMMA ::= (test "COMMA")*; in print_stmt.
yaccify star_test_COMMA ::= (star_test_COMMA (test "COMMA")) | ε;. // replaces (test "COMMA")*
// expand top-level with a single option in return_stmt ::= "RETURN" testlist? "NEWLINE"
massage testlist? to (testlist | ε) in return_stmt.
distribute in return_stmt.
// expand top-level with a single option in raise_stmt ::= "RAISE" expr ("COMMA" expr)? "NEWLINE"
massage ("COMMA" expr)? to (("COMMA" expr) | ε) in raise_stmt.
distribute in raise_stmt.
// replace star in import_stmt ::= ("COMMA" "NAME")*
extract star_COMMA_NAME ::= ("COMMA" "NAME")*; in import_stmt.
yaccify star_COMMA_NAME ::= (star_COMMA_NAME ("COMMA" "NAME")) | ε;. // replaces ("COMMA" "NAME")*
// replace embedded choice in import_stmt ::= "STAR" | ("NAME" star_COMMA_NAME)
extract pick_STAR_NAME ::= "STAR" | ("NAME" star_COMMA_NAME); in import_stmt.
// expand top-level with a single option in if_stmt ::= "IF" test "COLON" suite ("ELIF" test "COLON" suite)* ("ELSE" "COLON" suite)?
massage ("ELSE" "COLON" suite)? to (("ELSE" "COLON" suite) | ε) in if_stmt.
distribute in if_stmt.
// replace star in if_stmt ::= ("ELIF" test "COLON" suite)*
extract star_6 ::= ("ELIF" test "COLON" suite)*; in if_stmt.
yaccify star_6 ::= (star_6 ("ELIF" test "COLON" suite)) | ε;. // replaces ("ELIF" test "COLON" suite)*
// expand top-level with a single option in while_stmt ::= "WHILE" test "COLON" suite ("ELSE" "COLON" suite)?
massage ("ELSE" "COLON" suite)? to (("ELSE" "COLON" suite) | ε) in while_stmt.
distribute in while_stmt.
// expand top-level with a single option in for_stmt ::= "FOR" exprlist "IN" exprlist "COLON" suite ("ELSE" "COLON" suite)?
massage ("ELSE" "COLON" suite)? to (("ELSE" "COLON" suite) | ε) in for_stmt.
distribute in for_stmt.
// expand top-level with a single option in try_stmt ::= "TRY" "COLON" suite (except_clause "COLON" suite)* ("FINALLY" "COLON" suite)?
massage ("FINALLY" "COLON" suite)? to (("FINALLY" "COLON" suite) | ε) in try_stmt.
distribute in try_stmt.
// replace star in try_stmt ::= (except_clause "COLON" suite)*
extract star_7 ::= (except_clause "COLON" suite)*; in try_stmt.
yaccify star_7 ::= (star_7 (except_clause "COLON" suite)) | ε;. // replaces (except_clause "COLON" suite)*
// expand top-level with a single option in except_clause ::= "EXCEPT" (expr ("COMMA" expr)?)?
massage (expr ("COMMA" expr)?)? to ((expr ("COMMA" expr)?) | ε) in except_clause.
distribute in except_clause.
// replace optional in except_clause ::= ("COMMA" expr)?
extract opt_COMMA_expr ::= ("COMMA" expr)?; in except_clause.
massage ("COMMA" expr)? to (("COMMA" expr) | ε) in opt_COMMA_expr.
// replace star in suite ::= "NEWLINE"*
extract star_NEWLINE ::= "NEWLINE"*; in suite.
yaccify star_NEWLINE ::= (star_NEWLINE "NEWLINE") | ε;. // replaces "NEWLINE"*
// replace plus in suite ::= (stmt star_NEWLINE)+
extract plus_stmt ::= (stmt star_NEWLINE)+; in suite.
yaccify plus_stmt ::= (plus_stmt (stmt star_NEWLINE)) | (stmt star_NEWLINE);. // replaces (stmt star_NEWLINE)+
// expand top-level tail iteration in test ::= and_test ("OR" and_test)*
yaccify test ::= (and_test) | (test ("OR" and_test));. // replaces and_test ("OR" and_test)*
// expand top-level tail iteration in and_test ::= not_test ("AND" not_test)*
yaccify and_test ::= (not_test) | (and_test ("AND" not_test));. // replaces not_test ("AND" not_test)*
// expand top-level tail iteration in comparison ::= expr (comp_op expr)*
yaccify comparison ::= (expr) | (comparison (comp_op expr));. // replaces expr (comp_op expr)*
// expand top-level tail iteration in expr ::= term (("PLUS" | "MINUS") term)*
yaccify expr ::= (term) | (expr (("PLUS" | "MINUS") term));. // replaces term (("PLUS" | "MINUS") term)*
// replace embedded choice in expr ::= "PLUS" | "MINUS"
extract pick_PLUS_MINUS ::= "PLUS" | "MINUS"; in expr.
// expand top-level tail iteration in term ::= factor (("STAR" | "SLASH" | "PERCENT") factor)*
yaccify term ::= (factor) | (term (("STAR" | "SLASH" | "PERCENT") factor));. // replaces factor (("STAR" | "SLASH" | "PERCENT") factor)*
// replace embedded choice in term ::= "STAR" | "SLASH" | "PERCENT"
extract pick_12 ::= "STAR" | "SLASH" | "PERCENT"; in term.
// replace embedded choice in factor ::= "PLUS" | "MINUS"
extract pick_13 ::= "PLUS" | "MINUS"; in factor.
// replace star in factor ::= trailer*
extract star_trailer ::= trailer*; in factor.
yaccify star_trailer ::= (star_trailer trailer) | ε;. // replaces trailer*
// replace optional in atom ::= testlist?
extract opt_testlist ::= testlist?; in atom.
massage testlist? to (testlist | ε) in opt_testlist.
// replace optional in trailer ::= testlist?
extract opt_16 ::= testlist?; in trailer.
massage testlist? to (testlist | ε) in opt_16.
// replace optional in subscript ::= expr?
extract opt_expr ::= expr?; in subscript.
massage expr? to (expr | ε) in opt_expr.
// expand top-level with a single option in exprlist ::= expr ("COMMA" expr)* "COMMA"?
massage "COMMA"? to ("COMMA" | ε) in exprlist.
distribute in exprlist.
// replace star in exprlist ::= ("COMMA" expr)*
extract star_COMMA_expr ::= ("COMMA" expr)*; in exprlist.
yaccify star_COMMA_expr ::= (star_COMMA_expr ("COMMA" expr)) | ε;. // replaces ("COMMA" expr)*
// expand top-level with a single option in testlist ::= test ("COMMA" test)* "COMMA"?
massage "COMMA"? to ("COMMA" | ε) in testlist.
distribute in testlist.
// replace star in testlist ::= ("COMMA" test)*
extract star_COMMA_test ::= ("COMMA" test)*; in testlist.
yaccify star_COMMA_test ::= (star_COMMA_test ("COMMA" test)) | ε;. // replaces ("COMMA" test)*
// expand top-level with a single option in classdef ::= "CLASS" "NAME" parameters ("EQUAL" baselist)? "COLON" suite
massage ("EQUAL" baselist)? to (("EQUAL" baselist) | ε) in classdef.
distribute in classdef.
// replace star in baselist ::= ("COMMA" atom arguments)*
extract star_20 ::= ("COMMA" atom arguments)*; in baselist.
yaccify star_20 ::= (star_20 ("COMMA" atom arguments)) | ε;. // replaces ("COMMA" atom arguments)*
// expand top-level with a single option in arguments ::= "LPAR" testlist? "RPAR"
massage testlist? to (testlist | ε) in arguments.
distribute in arguments.

// Phase 2:
// Equating 2 cloned non-terminals:
equate opt_16 with opt_testlist.
equate pick_13 with pick_PLUS_MINUS.

// Phase 3:
// Renaming 5 generated non-terminals:
rename pick_12 to pick_old_multop globally. // RHS is "STAR" | "SLASH" | "PERCENT"
rename star_6 to star_ELIF globally. // RHS is (star_ELIF "ELIF" test "COLON" suite) | ε
rename star_1 to star_NEWLINE_stmt globally. // RHS is (star_NEWLINE_stmt pick_NEWLINE_stmt) | ε
rename star_20 to star_002 globally. // RHS is (star_002 "COMMA" atom arguments) | ε
rename star_7 to star_001 globally. // RHS is (star_001 except_clause "COLON" suite) | ε

// The generated bisonify transformations end here.

