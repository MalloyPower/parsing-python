// Automatically generated from 2.5.txt on 2016-11-23 at 16:45:44 +0000
// Transformations to convert (bisonify) 2.5.txt to 2.5.y

// replace embedded choice in file_input ::= "NEWLINE" | stmt
extract pick_NEWLINE_stmt ::= "NEWLINE" | stmt; in file_input.
// replace star in file_input ::= pick_NEWLINE_stmt*
extract star_1 ::= pick_NEWLINE_stmt*; in file_input.
yaccify star_1 ::= (star_1 pick_NEWLINE_stmt) | ε;. // replaces pick_NEWLINE_stmt*
// replace star in eval_input ::= "NEWLINE"*
extract star_NEWLINE ::= "NEWLINE"*; in eval_input.
yaccify star_NEWLINE ::= (star_NEWLINE "NEWLINE") | ε;. // replaces "NEWLINE"*
// expand top-level with a single option in decorator ::= "AT" dotted_name ("LPAR" arglist? "RPAR")? "NEWLINE"
massage ("LPAR" arglist? "RPAR")? to (("LPAR" arglist? "RPAR") | ε) in decorator.
distribute in decorator.
// replace optional in decorator ::= arglist?
extract opt_arglist ::= arglist?; in decorator.
massage arglist? to (arglist | ε) in opt_arglist.
yaccify decorators ::= (decorators decorator) | decorator;. // replaces decorator+
// expand top-level with a single option in funcdef ::= decorators? "DEF" "NAME" parameters "COLON" suite
massage decorators? to (decorators | ε) in funcdef.
distribute in funcdef.
// expand top-level with a single option in parameters ::= "LPAR" varargslist? "RPAR"
massage varargslist? to (varargslist | ε) in parameters.
distribute in parameters.
// replace optional in varargslist ::= ("EQUAL" test)?
extract opt_EQUAL_test ::= ("EQUAL" test)?; in varargslist.
massage ("EQUAL" test)? to (("EQUAL" test) | ε) in opt_EQUAL_test.
// replace star in varargslist ::= (fpdef opt_EQUAL_test "COMMA")*
extract star_fpdef_COMMA ::= (fpdef opt_EQUAL_test "COMMA")*; in varargslist.
yaccify star_fpdef_COMMA ::= (star_fpdef_COMMA (fpdef opt_EQUAL_test "COMMA")) | ε;. // replaces (fpdef opt_EQUAL_test "COMMA")*
// replace optional in varargslist ::= ("COMMA" "DOUBLESTAR" "NAME")?
extract opt_6 ::= ("COMMA" "DOUBLESTAR" "NAME")?; in varargslist.
massage ("COMMA" "DOUBLESTAR" "NAME")? to (("COMMA" "DOUBLESTAR" "NAME") | ε) in opt_6.
// replace embedded choice in varargslist ::= ("STAR" "NAME" opt_6) | ("DOUBLESTAR" "NAME")
extract pick_7 ::= ("STAR" "NAME" opt_6) | ("DOUBLESTAR" "NAME"); in varargslist.
// replace star in varargslist ::= ("COMMA" fpdef opt_EQUAL_test)*
extract star_COMMA_fpdef ::= ("COMMA" fpdef opt_EQUAL_test)*; in varargslist.
yaccify star_COMMA_fpdef ::= (star_COMMA_fpdef ("COMMA" fpdef opt_EQUAL_test)) | ε;. // replaces ("COMMA" fpdef opt_EQUAL_test)*
// replace optional in varargslist ::= "COMMA"?
extract opt_COMMA ::= "COMMA"?; in varargslist.
massage "COMMA"? to ("COMMA" | ε) in opt_COMMA.
// expand top-level with a single option in fplist ::= fpdef ("COMMA" fpdef)* "COMMA"?
massage "COMMA"? to ("COMMA" | ε) in fplist.
distribute in fplist.
// replace star in fplist ::= ("COMMA" fpdef)*
extract star_10 ::= ("COMMA" fpdef)*; in fplist.
yaccify star_10 ::= (star_10 ("COMMA" fpdef)) | ε;. // replaces ("COMMA" fpdef)*
// expand top-level with a single option in simple_stmt ::= small_stmt ("SEMI" small_stmt)* "SEMI"? "NEWLINE"
massage "SEMI"? to ("SEMI" | ε) in simple_stmt.
distribute in simple_stmt.
// replace star in simple_stmt ::= ("SEMI" small_stmt)*
extract star_SEMI_small_stmt ::= ("SEMI" small_stmt)*; in simple_stmt.
yaccify star_SEMI_small_stmt ::= (star_SEMI_small_stmt ("SEMI" small_stmt)) | ε;. // replaces ("SEMI" small_stmt)*
// replace embedded choice in expr_stmt ::= yield_expr | testlist
extract pick_yield_expr_testlist ::= yield_expr | testlist; in expr_stmt.
// replace star in expr_stmt ::= ("EQUAL" pick_yield_expr_testlist)*
extract star_EQUAL ::= ("EQUAL" pick_yield_expr_testlist)*; in expr_stmt.
yaccify star_EQUAL ::= (star_EQUAL ("EQUAL" pick_yield_expr_testlist)) | ε;. // replaces ("EQUAL" pick_yield_expr_testlist)*
// replace embedded choice in expr_stmt ::= (augassign pick_yield_expr_testlist) | star_EQUAL
extract pick_augassign ::= (augassign pick_yield_expr_testlist) | star_EQUAL; in expr_stmt.
// expand top-level with a single choice in print_stmt ::= "PRINT" ((test ("COMMA" test)* "COMMA"?)? | ("RIGHTSHIFT" test (("COMMA" test)+ "COMMA"?)?))
distribute in print_stmt.
// replace star in print_stmt ::= ("COMMA" test)*
extract star_COMMA_test ::= ("COMMA" test)*; in print_stmt.
yaccify star_COMMA_test ::= (star_COMMA_test ("COMMA" test)) | ε;. // replaces ("COMMA" test)*
// replace optional in print_stmt ::= "COMMA"?
extract opt_16 ::= "COMMA"?; in print_stmt.
massage "COMMA"? to ("COMMA" | ε) in opt_16.
// replace optional in print_stmt ::= (test star_COMMA_test opt_16)?
extract opt_test ::= (test star_COMMA_test opt_16)?; in print_stmt.
massage (test star_COMMA_test opt_16)? to ((test star_COMMA_test opt_16) | ε) in opt_test.
// replace plus in print_stmt ::= ("COMMA" test)+
extract plus_COMMA_test ::= ("COMMA" test)+; in print_stmt.
yaccify plus_COMMA_test ::= (plus_COMMA_test ("COMMA" test)) | ("COMMA" test);. // replaces ("COMMA" test)+
// replace optional in print_stmt ::= (plus_COMMA_test opt_16)?
extract opt_19 ::= (plus_COMMA_test opt_16)?; in print_stmt.
massage (plus_COMMA_test opt_16)? to ((plus_COMMA_test opt_16) | ε) in opt_19.
// expand top-level with a single option in return_stmt ::= "RETURN" testlist?
massage testlist? to (testlist | ε) in return_stmt.
distribute in return_stmt.
// expand top-level with a single option in raise_stmt ::= "RAISE" (test ("COMMA" test ("COMMA" test)?)?)?
massage (test ("COMMA" test ("COMMA" test)?)?)? to ((test ("COMMA" test ("COMMA" test)?)?) | ε) in raise_stmt.
distribute in raise_stmt.
// replace optional in raise_stmt ::= ("COMMA" test)?
extract opt_COMMA_test ::= ("COMMA" test)?; in raise_stmt.
massage ("COMMA" test)? to (("COMMA" test) | ε) in opt_COMMA_test.
// replace optional in raise_stmt ::= ("COMMA" test opt_COMMA_test)?
extract opt_21 ::= ("COMMA" test opt_COMMA_test)?; in raise_stmt.
massage ("COMMA" test opt_COMMA_test)? to (("COMMA" test opt_COMMA_test) | ε) in opt_21.
// replace star in import_from ::= "DOT"*
extract star_DOT ::= "DOT"*; in import_from.
yaccify star_DOT ::= (star_DOT "DOT") | ε;. // replaces "DOT"*
// replace plus in import_from ::= "DOT"+
extract plus_DOT ::= "DOT"+; in import_from.
yaccify plus_DOT ::= (plus_DOT "DOT") | "DOT";. // replaces "DOT"+
// replace embedded choice in import_from ::= (star_DOT dotted_name) | plus_DOT
extract pick_dotted_name ::= (star_DOT dotted_name) | plus_DOT; in import_from.
// replace embedded choice in import_from ::= "STAR" | ("LPAR" import_as_names "RPAR") | import_as_names
extract pick_25 ::= "STAR" | ("LPAR" import_as_names "RPAR") | import_as_names; in import_from.
// replace embedded choice in import_as_name ::= "AS" | "NAME"
extract pick_AS_NAME ::= "AS" | "NAME"; in import_as_name.
// replace optional in import_as_name ::= (pick_AS_NAME "NAME")?
extract opt_NAME ::= (pick_AS_NAME "NAME")?; in import_as_name.
massage (pick_AS_NAME "NAME")? to ((pick_AS_NAME "NAME") | ε) in opt_NAME.
// replace embedded choice in dotted_as_name ::= "AS" | "NAME"
extract pick_28 ::= "AS" | "NAME"; in dotted_as_name.
// replace optional in dotted_as_name ::= (pick_28 "NAME")?
extract opt_29 ::= (pick_28 "NAME")?; in dotted_as_name.
massage (pick_28 "NAME")? to ((pick_28 "NAME") | ε) in opt_29.
// expand top-level with a single option in import_as_names ::= import_as_name ("COMMA" import_as_name)* "COMMA"?
massage "COMMA"? to ("COMMA" | ε) in import_as_names.
distribute in import_as_names.
// replace star in import_as_names ::= ("COMMA" import_as_name)*
extract star_COMMA_import_as_name ::= ("COMMA" import_as_name)*; in import_as_names.
yaccify star_COMMA_import_as_name ::= (star_COMMA_import_as_name ("COMMA" import_as_name)) | ε;. // replaces ("COMMA" import_as_name)*
// expand top-level tail iteration in dotted_as_names ::= dotted_as_name ("COMMA" dotted_as_name)*
yaccify dotted_as_names ::= (dotted_as_name) | (dotted_as_names ("COMMA" dotted_as_name));. // replaces dotted_as_name ("COMMA" dotted_as_name)*
// expand top-level tail iteration in dotted_name ::= "NAME" ("DOT" "NAME")*
yaccify dotted_name ::= ("NAME") | (dotted_name ("DOT" "NAME"));. // replaces "NAME" ("DOT" "NAME")*
// replace star in global_stmt ::= ("COMMA" "NAME")*
extract star_COMMA_NAME ::= ("COMMA" "NAME")*; in global_stmt.
yaccify star_COMMA_NAME ::= (star_COMMA_NAME ("COMMA" "NAME")) | ε;. // replaces ("COMMA" "NAME")*
// expand top-level with a single option in exec_stmt ::= "EXEC" expr ("IN" test ("COMMA" test)?)?
massage ("IN" test ("COMMA" test)?)? to (("IN" test ("COMMA" test)?) | ε) in exec_stmt.
distribute in exec_stmt.
// replace optional in exec_stmt ::= ("COMMA" test)?
extract opt_32 ::= ("COMMA" test)?; in exec_stmt.
massage ("COMMA" test)? to (("COMMA" test) | ε) in opt_32.
// expand top-level with a single option in assert_stmt ::= "ASSERT" test ("COMMA" test)?
massage ("COMMA" test)? to (("COMMA" test) | ε) in assert_stmt.
distribute in assert_stmt.
// expand top-level with a single option in if_stmt ::= "IF" test "COLON" suite ("ELIF" test "COLON" suite)* ("ELSE" "COLON" suite)?
massage ("ELSE" "COLON" suite)? to (("ELSE" "COLON" suite) | ε) in if_stmt.
distribute in if_stmt.
// replace star in if_stmt ::= ("ELIF" test "COLON" suite)*
extract star_33 ::= ("ELIF" test "COLON" suite)*; in if_stmt.
yaccify star_33 ::= (star_33 ("ELIF" test "COLON" suite)) | ε;. // replaces ("ELIF" test "COLON" suite)*
// expand top-level with a single option in while_stmt ::= "WHILE" test "COLON" suite ("ELSE" "COLON" suite)?
massage ("ELSE" "COLON" suite)? to (("ELSE" "COLON" suite) | ε) in while_stmt.
distribute in while_stmt.
// expand top-level with a single option in for_stmt ::= "FOR" exprlist "IN" testlist "COLON" suite ("ELSE" "COLON" suite)?
massage ("ELSE" "COLON" suite)? to (("ELSE" "COLON" suite) | ε) in for_stmt.
distribute in for_stmt.
// expand top-level with a single choice in try_stmt ::= "TRY" "COLON" suite (((except_clause "COLON" suite)+ ("ELSE" "COLON" suite)? ("FINALLY" "COLON" suite)?) | ("FINALLY" "COLON" suite))
distribute in try_stmt.
// replace plus in try_stmt ::= (except_clause "COLON" suite)+
extract plus_34 ::= (except_clause "COLON" suite)+; in try_stmt.
yaccify plus_34 ::= (plus_34 (except_clause "COLON" suite)) | (except_clause "COLON" suite);. // replaces (except_clause "COLON" suite)+
// replace optional in try_stmt ::= ("ELSE" "COLON" suite)?
extract opt_35 ::= ("ELSE" "COLON" suite)?; in try_stmt.
massage ("ELSE" "COLON" suite)? to (("ELSE" "COLON" suite) | ε) in opt_35.
// replace optional in try_stmt ::= ("FINALLY" "COLON" suite)?
extract opt_36 ::= ("FINALLY" "COLON" suite)?; in try_stmt.
massage ("FINALLY" "COLON" suite)? to (("FINALLY" "COLON" suite) | ε) in opt_36.
// expand top-level with a single option in with_stmt ::= "WITH" test with_var? "COLON" suite
massage with_var? to (with_var | ε) in with_stmt.
distribute in with_stmt.
// expand top-level with a single choice in with_var ::= ("AS" | "NAME") expr
distribute in with_var.
// expand top-level with a single option in except_clause ::= "EXCEPT" (test ("COMMA" test)?)?
massage (test ("COMMA" test)?)? to ((test ("COMMA" test)?) | ε) in except_clause.
distribute in except_clause.
// replace optional in except_clause ::= ("COMMA" test)?
extract opt_37 ::= ("COMMA" test)?; in except_clause.
massage ("COMMA" test)? to (("COMMA" test) | ε) in opt_37.
// replace plus in suite ::= stmt+
extract plus_stmt ::= stmt+; in suite.
yaccify plus_stmt ::= (plus_stmt stmt) | stmt;. // replaces stmt+
// expand top-level with a single option in testlist_safe ::= old_test (("COMMA" old_test)+ "COMMA"?)?
massage (("COMMA" old_test)+ "COMMA"?)? to ((("COMMA" old_test)+ "COMMA"?) | ε) in testlist_safe.
distribute in testlist_safe.
// replace plus in testlist_safe ::= ("COMMA" old_test)+
extract plus_COMMA_old_test ::= ("COMMA" old_test)+; in testlist_safe.
yaccify plus_COMMA_old_test ::= (plus_COMMA_old_test ("COMMA" old_test)) | ("COMMA" old_test);. // replaces ("COMMA" old_test)+
// replace optional in testlist_safe ::= "COMMA"?
extract opt_40 ::= "COMMA"?; in testlist_safe.
massage "COMMA"? to ("COMMA" | ε) in opt_40.
// expand top-level with a single option in old_lambdef ::= "LAMBDA" varargslist? "COLON" old_test
massage varargslist? to (varargslist | ε) in old_lambdef.
distribute in old_lambdef.
// replace optional in test ::= ("IF" or_test "ELSE" test)?
extract opt_41 ::= ("IF" or_test "ELSE" test)?; in test.
massage ("IF" or_test "ELSE" test)? to (("IF" or_test "ELSE" test) | ε) in opt_41.
// expand top-level tail iteration in or_test ::= and_test ("OR" and_test)*
yaccify or_test ::= (and_test) | (or_test ("OR" and_test));. // replaces and_test ("OR" and_test)*
// expand top-level tail iteration in and_test ::= not_test ("AND" not_test)*
yaccify and_test ::= (not_test) | (and_test ("AND" not_test));. // replaces not_test ("AND" not_test)*
// expand top-level tail iteration in comparison ::= expr (comp_op expr)*
yaccify comparison ::= (expr) | (comparison (comp_op expr));. // replaces expr (comp_op expr)*
// expand top-level tail iteration in expr ::= xor_expr ("BAR" xor_expr)*
yaccify expr ::= (xor_expr) | (expr ("BAR" xor_expr));. // replaces xor_expr ("BAR" xor_expr)*
// expand top-level tail iteration in xor_expr ::= and_expr ("CIRCUMFLEX" and_expr)*
yaccify xor_expr ::= (and_expr) | (xor_expr ("CIRCUMFLEX" and_expr));. // replaces and_expr ("CIRCUMFLEX" and_expr)*
// expand top-level tail iteration in and_expr ::= shift_expr ("AMPERSAND" shift_expr)*
yaccify and_expr ::= (shift_expr) | (and_expr ("AMPERSAND" shift_expr));. // replaces shift_expr ("AMPERSAND" shift_expr)*
// expand top-level tail iteration in shift_expr ::= arith_expr (("LEFTSHIFT" | "RIGHTSHIFT") arith_expr)*
yaccify shift_expr ::= (arith_expr) | (shift_expr (("LEFTSHIFT" | "RIGHTSHIFT") arith_expr));. // replaces arith_expr (("LEFTSHIFT" | "RIGHTSHIFT") arith_expr)*
// replace embedded choice in shift_expr ::= "LEFTSHIFT" | "RIGHTSHIFT"
extract pick_LEFTSHIFT_RIGHTSHIFT ::= "LEFTSHIFT" | "RIGHTSHIFT"; in shift_expr.
// expand top-level tail iteration in arith_expr ::= term (("PLUS" | "MINUS") term)*
yaccify arith_expr ::= (term) | (arith_expr (("PLUS" | "MINUS") term));. // replaces term (("PLUS" | "MINUS") term)*
// replace embedded choice in arith_expr ::= "PLUS" | "MINUS"
extract pick_PLUS_MINUS ::= "PLUS" | "MINUS"; in arith_expr.
// expand top-level tail iteration in term ::= factor (("STAR" | "SLASH" | "PERCENT" | "DOUBLESLASH") factor)*
yaccify term ::= (factor) | (term (("STAR" | "SLASH" | "PERCENT" | "DOUBLESLASH") factor));. // replaces factor (("STAR" | "SLASH" | "PERCENT" | "DOUBLESLASH") factor)*
// replace embedded choice in term ::= "STAR" | "SLASH" | "PERCENT" | "DOUBLESLASH"
extract pick_44 ::= "STAR" | "SLASH" | "PERCENT" | "DOUBLESLASH"; in term.
// replace embedded choice in factor ::= "PLUS" | "MINUS" | "TILDE"
extract pick_45 ::= "PLUS" | "MINUS" | "TILDE"; in factor.
// expand top-level with a single option in power ::= atom trailer* ("DOUBLESTAR" factor)?
massage ("DOUBLESTAR" factor)? to (("DOUBLESTAR" factor) | ε) in power.
distribute in power.
// replace star in power ::= trailer*
extract star_trailer ::= trailer*; in power.
yaccify star_trailer ::= (star_trailer trailer) | ε;. // replaces trailer*
// replace embedded choice in atom ::= yield_expr | testlist_gexp
extract pick_yield_expr_testlist_gexp ::= yield_expr | testlist_gexp; in atom.
// replace optional in atom ::= pick_yield_expr_testlist_gexp?
extract opt_48 ::= pick_yield_expr_testlist_gexp?; in atom.
massage pick_yield_expr_testlist_gexp? to (pick_yield_expr_testlist_gexp | ε) in opt_48.
// replace optional in atom ::= listmaker?
extract opt_listmaker ::= listmaker?; in atom.
massage listmaker? to (listmaker | ε) in opt_listmaker.
// replace optional in atom ::= dictmaker?
extract opt_dictmaker ::= dictmaker?; in atom.
massage dictmaker? to (dictmaker | ε) in opt_dictmaker.
// replace plus in atom ::= "STRING"+
extract plus_STRING ::= "STRING"+; in atom.
yaccify plus_STRING ::= (plus_STRING "STRING") | "STRING";. // replaces "STRING"+
// expand top-level with a single choice in listmaker ::= test (list_for | (("COMMA" test)* "COMMA"?))
distribute in listmaker.
// replace star in listmaker ::= ("COMMA" test)*
extract star_52 ::= ("COMMA" test)*; in listmaker.
yaccify star_52 ::= (star_52 ("COMMA" test)) | ε;. // replaces ("COMMA" test)*
// replace optional in listmaker ::= "COMMA"?
extract opt_53 ::= "COMMA"?; in listmaker.
massage "COMMA"? to ("COMMA" | ε) in opt_53.
// expand top-level with a single choice in testlist_gexp ::= test (gen_for | (("COMMA" test)* "COMMA"?))
distribute in testlist_gexp.
// replace star in testlist_gexp ::= ("COMMA" test)*
extract star_54 ::= ("COMMA" test)*; in testlist_gexp.
yaccify star_54 ::= (star_54 ("COMMA" test)) | ε;. // replaces ("COMMA" test)*
// replace optional in testlist_gexp ::= "COMMA"?
extract opt_55 ::= "COMMA"?; in testlist_gexp.
massage "COMMA"? to ("COMMA" | ε) in opt_55.
// expand top-level with a single option in lambdef ::= "LAMBDA" varargslist? "COLON" test
massage varargslist? to (varargslist | ε) in lambdef.
distribute in lambdef.
// replace optional in trailer ::= arglist?
extract opt_56 ::= arglist?; in trailer.
massage arglist? to (arglist | ε) in opt_56.
// expand top-level with a single option in subscriptlist ::= subscript ("COMMA" subscript)* "COMMA"?
massage "COMMA"? to ("COMMA" | ε) in subscriptlist.
distribute in subscriptlist.
// replace star in subscriptlist ::= ("COMMA" subscript)*
extract star_COMMA_subscript ::= ("COMMA" subscript)*; in subscriptlist.
yaccify star_COMMA_subscript ::= (star_COMMA_subscript ("COMMA" subscript)) | ε;. // replaces ("COMMA" subscript)*
// replace optional in subscript ::= test?
extract opt_58 ::= test?; in subscript.
massage test? to (test | ε) in opt_58.
// replace optional in subscript ::= sliceop?
extract opt_sliceop ::= sliceop?; in subscript.
massage sliceop? to (sliceop | ε) in opt_sliceop.
// expand top-level with a single option in sliceop ::= "COLON" test?
massage test? to (test | ε) in sliceop.
distribute in sliceop.
// expand top-level with a single option in exprlist ::= expr ("COMMA" expr)* "COMMA"?
massage "COMMA"? to ("COMMA" | ε) in exprlist.
distribute in exprlist.
// replace star in exprlist ::= ("COMMA" expr)*
extract star_COMMA_expr ::= ("COMMA" expr)*; in exprlist.
yaccify star_COMMA_expr ::= (star_COMMA_expr ("COMMA" expr)) | ε;. // replaces ("COMMA" expr)*
// expand top-level with a single option in testlist ::= test ("COMMA" test)* "COMMA"?
massage "COMMA"? to ("COMMA" | ε) in testlist.
distribute in testlist.
// replace star in testlist ::= ("COMMA" test)*
extract star_61 ::= ("COMMA" test)*; in testlist.
yaccify star_61 ::= (star_61 ("COMMA" test)) | ε;. // replaces ("COMMA" test)*
// expand top-level with a single option in dictmaker ::= test "COLON" test ("COMMA" test "COLON" test)* "COMMA"?
massage "COMMA"? to ("COMMA" | ε) in dictmaker.
distribute in dictmaker.
// replace star in dictmaker ::= ("COMMA" test "COLON" test)*
extract star_62 ::= ("COMMA" test "COLON" test)*; in dictmaker.
yaccify star_62 ::= (star_62 ("COMMA" test "COLON" test)) | ε;. // replaces ("COMMA" test "COLON" test)*
// expand top-level with a single option in classdef ::= "CLASS" "NAME" ("LPAR" testlist? "RPAR")? "COLON" suite
massage ("LPAR" testlist? "RPAR")? to (("LPAR" testlist? "RPAR") | ε) in classdef.
distribute in classdef.
// replace optional in classdef ::= testlist?
extract opt_testlist ::= testlist?; in classdef.
massage testlist? to (testlist | ε) in opt_testlist.
// replace star in arglist ::= (argument "COMMA")*
extract star_argument_COMMA ::= (argument "COMMA")*; in arglist.
yaccify star_argument_COMMA ::= (star_argument_COMMA (argument "COMMA")) | ε;. // replaces (argument "COMMA")*
// replace optional in arglist ::= "COMMA"?
extract opt_65 ::= "COMMA"?; in arglist.
massage "COMMA"? to ("COMMA" | ε) in opt_65.
// replace optional in arglist ::= ("COMMA" "DOUBLESTAR" test)?
extract opt_66 ::= ("COMMA" "DOUBLESTAR" test)?; in arglist.
massage ("COMMA" "DOUBLESTAR" test)? to (("COMMA" "DOUBLESTAR" test) | ε) in opt_66.
// replace embedded choice in arglist ::= (argument opt_65) | ("STAR" test opt_66) | ("DOUBLESTAR" test)
extract pick_67 ::= (argument opt_65) | ("STAR" test opt_66) | ("DOUBLESTAR" test); in arglist.
// replace optional in argument ::= gen_for?
extract opt_gen_for ::= gen_for?; in argument.
massage gen_for? to (gen_for | ε) in opt_gen_for.
// expand top-level with a single option in list_for ::= "FOR" exprlist "IN" testlist_safe list_iter?
massage list_iter? to (list_iter | ε) in list_for.
distribute in list_for.
// expand top-level with a single option in list_if ::= "IF" old_test list_iter?
massage list_iter? to (list_iter | ε) in list_if.
distribute in list_if.
// expand top-level with a single option in gen_for ::= "FOR" exprlist "IN" or_test gen_iter?
massage gen_iter? to (gen_iter | ε) in gen_for.
distribute in gen_for.
// expand top-level with a single option in gen_if ::= "IF" old_test gen_iter?
massage gen_iter? to (gen_iter | ε) in gen_if.
distribute in gen_if.
// expand top-level tail iteration in testlist1 ::= test ("COMMA" test)*
yaccify testlist1 ::= (test) | (testlist1 ("COMMA" test));. // replaces test ("COMMA" test)*
// expand top-level with a single option in yield_expr ::= "YIELD" testlist?
massage testlist? to (testlist | ε) in yield_expr.
distribute in yield_expr.

// Phase 2:
// Equating 13 cloned non-terminals:
equate star_54 with star_COMMA_test.
equate opt_55 with opt_COMMA.
equate opt_65 with opt_COMMA.
equate opt_32 with opt_COMMA_test.
equate star_52 with star_COMMA_test.
equate opt_53 with opt_COMMA.
equate star_61 with star_COMMA_test.
equate opt_40 with opt_COMMA.
equate opt_16 with opt_COMMA.
equate opt_37 with opt_COMMA_test.
equate opt_56 with opt_arglist.
equate pick_28 with pick_AS_NAME.
equate opt_29 with opt_NAME.

// Phase 3:
// Renaming 19 generated non-terminals:
rename opt_58 to opt_test_only globally. // RHS is test | ε
rename opt_36 to opt_FINALLY globally. // RHS is ("FINALLY" "COLON" suite) | ε
rename opt_66 to opt_DOUBLESTAR_test globally. // RHS is ("COMMA" "DOUBLESTAR" test) | ε
rename star_10 to star_fpdef_notest globally. // RHS is (star_fpdef_notest "COMMA" fpdef) | ε
rename star_62 to star_test_COLON_test globally. // RHS is (star_test_COLON_test "COMMA" test "COLON" test) | ε
rename opt_41 to opt_IF_ELSE globally. // RHS is ("IF" or_test "ELSE" test) | ε
rename pick_45 to pick_unop globally. // RHS is "PLUS" | "MINUS" | "TILDE"
rename pick_44 to pick_multop globally. // RHS is "STAR" | "SLASH" | "PERCENT" | "DOUBLESLASH"
rename opt_19 to opt_test_2 globally. // RHS is (plus_COMMA_test opt_COMMA) | ε
rename opt_48 to opt_yield_test_gexp globally. // RHS is pick_yield_expr_testlist_gexp | ε
rename opt_35 to opt_ELSE globally. // RHS is ("ELSE" "COLON" suite) | ε
rename star_33 to star_ELIF globally. // RHS is (star_ELIF "ELIF" test "COLON" suite) | ε
rename opt_21 to opt_test_3 globally. // RHS is ("COMMA" test opt_COMMA_test) | ε
rename opt_6 to opt_DOUBLESTAR_NAME globally. // RHS is ("COMMA" "DOUBLESTAR" "NAME") | ε
rename plus_34 to plus_except globally. // RHS is (plus_except except_clause "COLON" suite) | (except_clause "COLON" suite)
rename star_1 to star_NEWLINE_stmt globally. // RHS is (star_NEWLINE_stmt pick_NEWLINE_stmt) | ε
rename pick_25 to pick_STAR_import globally. // RHS is "STAR" | ("LPAR" import_as_names "RPAR") | import_as_names
rename pick_67 to pick_argument_short globally. // RHS is (argument opt_COMMA) | ("STAR" test opt_DOUBLESTAR_test) | ("DOUBLESTAR" test)
rename pick_7 to pick_STAR_DOUBLESTAR globally. // RHS is ("STAR" "NAME" opt_DOUBLESTAR_NAME) | ("DOUBLESTAR" "NAME")

// The generated bisonify transformations end here.

